// Generated by CoffeeScript 1.7.1
var async, csvParser, excelParser, fs, iconv, jschardet, parse, xls, xlsx, _;

iconv = require('iconv-lite');

parse = require('csv-parse');

jschardet = require("jschardet");

fs = require('fs');

async = require('async');

xlsx = require('xlsx');

xls = require('xlsjs');

_ = require('underscore');

csvParser = function(file, opts, callback) {
  var charset, parser, _ref;
  if (typeof opts === 'function') {
    _ref = [{}, opts], opts = _ref[0], callback = _ref[1];
  }
  charset = opts.charset || null;
  parser = null;
  return async.series([
    function(cb) {
      var stream;
      if (charset != null) {
        return cb();
      }
      stream = fs.createReadStream(file, {
        end: 5 * 1024
      });
      return stream.on('readable', function() {
        var buf, _ref1;
        if (charset != null) {
          return;
        }
        buf = stream.read();
        charset = (_ref1 = jschardet.detect(buf)) != null ? _ref1.encoding : void 0;
        stream.close();
        return cb();
      });
    }
  ], function(err) {
    var csvOpts, p;
    if (err != null) {
      return callback(err);
    }
    csvOpts = {};
    csvOpts.columns = opts.columns || true;
    csvOpts.delimiter = opts.delimiter || ';';
    csvOpts.trim = opts.trim || true;
    csvOpts.skip_empty_lines = opts.skip_empty_lines || true;
    p = {
      type: 'csv',
      charset: charset,
      events: {},
      on: function(event, cb) {
        return this.events[event] = cb;
      },
      stream: function() {
        var endCallback, errorCallback, rowCallback, stream;
        if (parser != null) {
          return;
        }
        parser = parse(csvOpts);
        stream = fs.createReadStream(file);
        rowCallback = this.events['row'];
        endCallback = this.events['end'];
        errorCallback = this.events['error'];
        parser.on('readable', function() {
          var row, _results;
          row = parser.read();
          _results = [];
          while ((row != null)) {
            if (rowCallback != null) {
              rowCallback(row);
            }
            _results.push(row = parser.read());
          }
          return _results;
        });
        parser.on('finish', function() {
          return process.nextTick(function() {
            if (endCallback()) {
              return endCallback();
            }
          });
        });
        parser.on('error', function(err) {
          if (errorCallback != null) {
            return errorCallback(err);
          }
        });
        p = stream;
        if ((charset != null) && charset !== 'utf-8') {
          p = stream.pipe(iconv.decodeStream(charset));
        }
        return p.pipe(parser);
      },
      read: function(callback) {
        var rows, stream;
        if (parser != null) {
          return;
        }
        parser = parse(csvOpts);
        stream = fs.createReadStream(file);
        rows = [];
        parser.on('readable', function() {
          var row, _results;
          row = parser.read();
          _results = [];
          while ((row != null)) {
            rows.push(row);
            _results.push(row = parser.read());
          }
          return _results;
        });
        parser.on('finish', function() {
          return callback(null, rows);
        });
        p = stream;
        if ((charset != null) && charset !== 'utf-8') {
          p = stream.pipe(iconv.decodeStream(charset));
        }
        return p.pipe(parser);
      }
    };
    return callback(null, p);
  });
};

excelParser = function(file, opts, callback) {
  var header, p, parser, r, row, rows, sheet, val, workbook, _ref;
  if (typeof opts === 'function') {
    _ref = [{}, opts], opts = _ref[0], callback = _ref[1];
  }
  parser = xlsx;
  if (file.toLowerCase().match(/xls$/)) {
    parser = xls;
  }
  sheet = null;
  workbook = parser.readFile(file);
  opts = _.clone(opts);
  if (opts.range === 'auto') {
    sheet = workbook.Sheets[workbook.SheetNames[opts.sheet || 0]];
    r = parser.utils.decode_range(sheet["!ref"]);
    row = 0;
    while (row < 10 && r.e.r > 10) {
      val = sheet[parser.utils.encode_col(0) + parser.utils.encode_row(row)];
      if (val === void 0) {
        opts.range = row + 1;
        break;
      }
      row++;
    }
    if (opts.range === 'auto') {
      delete opts.range;
    }
  }
  if ((opts.header != null) && typeof opts.header === 'function' && (opts.range == null)) {
    sheet = workbook.Sheets[workbook.SheetNames[opts.sheet || 0]];
    rows = parser.utils.sheet_to_json(sheet, opts);
    header = opts.header(rows);
    delete opts.header;
    if (header != null) {
      opts.header = header;
    }
    sheet = null;
  }
  p = {
    type: parser === xls ? 'xls' : 'xlsx',
    events: {},
    on: function(event, cb) {
      return this.events[event] = cb;
    },
    columns: opts.columns || null,
    read: function(callback) {
      if (sheet == null) {
        sheet = workbook.Sheets[workbook.SheetNames[opts.sheet || 0]];
      }
      return callback(null, parser.utils.sheet_to_json(sheet, opts));
    },
    stream: function() {
      var endCallback, errorCallback, rowCallback, _i, _len, _ref1;
      if (sheet == null) {
        sheet = workbook.Sheets[workbook.SheetNames[opts.sheet || 0]];
      }
      rowCallback = this.events['row'];
      endCallback = this.events['end'];
      errorCallback = this.events['error'];
      _ref1 = parser.utils.sheet_to_json(sheet, opts);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        row = _ref1[_i];
        if (rowCallback != null) {
          rowCallback(row);
        }
      }
      if (endCallback()) {
        return endCallback();
      }
    },
    props: workbook.Props
  };
  return callback(null, p);
};

module.exports = {
  create: function(file, opts, callback) {
    var parser, _ref;
    if (typeof opts === 'function') {
      _ref = [{}, opts], opts = _ref[0], callback = _ref[1];
    }
    parser = null;
    return async.series([
      function(cb) {
        return fs.exists(file, function(exists) {
          return cb(exists ? null : "file '" + file + "' not found");
        });
      }, function(cb) {
        if (file.toLowerCase().match(/(csv|txt)$/)) {
          parser = csvParser;
        }
        if (file.toLowerCase().match(/(xls|xlsx)$/)) {
          parser = excelParser;
        }
        return cb();
      }
    ], function(err) {
      if (parser == null) {
        err = "Unknown file type: '" + file + "'";
      }
      if (err != null) {
        return callback(err);
      }
      return parser(file, opts, callback);
    });
  }
};
